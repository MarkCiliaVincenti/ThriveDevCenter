@page "/reports/{Id:long}"
@inject HttpClient http
@inject NotificationHandler notificationHandler
@inject NavigationManager navigationManager
@inject CurrentUserInfo currentUserInfo
@inherits SingleResourcePage<CrashReportDTO, CrashReportUpdated>
@using ThriveDevCenter.Shared.Models
@using ThriveDevCenter.Client.Services
@using ThriveDevCenter.Shared
@using ThriveDevCenter.Shared.Models.Enums
@using ThriveDevCenter.Shared.Notifications
@implements IAsyncDisposable

<SingleResourceDisplayer Error="@Error" Loading="@Loading" HasData="@(Data != null)">
    @if (Data != null)
    {
        <h3>
            Crash Report @Data.Id
            @if (Data.State == ReportState.Closed)
            {
                <span class="badge badge-success ml-2">Closed</span>
            } else if (Data.State == ReportState.Duplicate)
            {
                <span class="badge badge-warning ml-2">Duplicate</span>
            }

            @if (!Data.Public)
            {
                <span class="badge badge-secondary ml-2">Private</span>
            }
        </h3>

        <ul>
            <li><strong>Crash Happened At</strong>: @Data.HappenedAt.ToLocalTime().ToString("G")</li>
            <li><strong>Crash Reason</strong>: @Data.ExitCodeOrSignal</li>
            <li><strong>Version</strong>: @Data.Version</li>
            <li><strong>Store Version</strong>: @Data.Store</li>
            <li><strong>Platform</strong>: @Data.Platform</li>
            <li><strong>State</strong>: @Data.State</li>

            @if (Data.DuplicateOfId.HasValue)
            {
                <li><strong>Duplicate Of</strong>: <NavLink href="@($"/reports/{Data.DuplicateOfId.Value}")">
                    Report @Data.DuplicateOfId.Value
                </NavLink></li>
            }

            <li><strong>Created At</strong>: @Data.CreatedAt.ToLocalTime().ToString("G")</li>
            <li><strong>Updated At</strong>: @Data.UpdatedAt.ToLocalTime().ToString("G")</li>
        </ul>

        <StatusMessageShower Type="@topStatusType" Message="@topStatus" />

        <AdminResourceDeleteButtons UsesSoftDelete="@false" Name="@($"Crash Report {Data.Id}")" Id="@Data.Id"
                                    DeleteURLBase="api/v1/CrashReport"
                                    DeletePromptTitle="Delete this Crash Report?" />

        <div class="row">
            <div class="col-12 col-xl">
                <h4>Duplicates</h4>

                @if (fetchingDuplicates)
                {
                    <span class="spinner-border spinner-border" role="status" aria-hidden="true"></span>
                } else if (duplicates != null)
                {
                    @if (duplicates.Count < 1)
                    {
                        <span>Nothing is a duplicate of this report.</span>
                    }
                    else
                    {
                        <ul>
                            @foreach (var duplicate in duplicates.Take(showAllDuplicates ?
                                AppInfo.MaximumDuplicateReports : SmallDuplicateAmount))
                            {
                                <li><NavLink href="@($"/reports/{duplicate}")">Report @duplicate</NavLink></li>
                            }
                        </ul>

                        @if (duplicates.Count >= AppInfo.MaximumDuplicateReports)
                        {
                            <p>
                                This report has so many duplicates that not all can be shown.
                                Only @AppInfo.MaximumDuplicateReports are shown.
                            </p>
                        }

                        @if (duplicates.Count > SmallDuplicateAmount)
                        {
                            @if (showAllDuplicates)
                            {
                                <Button ButtonStyle="secondary"
                                        OnPressed="@(() => SetDuplicatesFullShowing(false))">
                                    Show Only The First Duplicates
                                </Button>
                            }
                            else
                            {
                                <Button ButtonStyle="secondary"
                                        OnPressed="@(() => SetDuplicatesFullShowing(true))">
                                    Show All @duplicates.Count Duplicates
                                </Button>
                            }
                        }
                    }
                }

                <h3>Description</h3>

                @* TODO: move this to markdown once the XSS resistant version is in nuget *@

                <pre>@Data.Description</pre>

                <AccessLimited AutoRedirectIfNotLoggedIn="false" RequiredAccess="UserAccessLevel.User">
                    <AuthorizedContent>
                        @if (Data.DescriptionLastEdited.HasValue)
                        {
                            <p>Description last edited at
                                @Data.DescriptionLastEdited.Value.ToLocalTime().ToString("G") by
                                <UsernameDisplayer UserId="@Data.DescriptionLastEditedById"/></p>
                        }
                    </AuthorizedContent>
                    <AccessMissingContent>
                        @if (Data.DescriptionLastEdited.HasValue)
                        {
                            <p>
                                Description last edited at
                                @Data.DescriptionLastEdited.Value.ToLocalTime().ToString("G")
                            </p>
                        }
                    </AccessMissingContent>
                </AccessLimited>

                <AccessLimited AutoRedirectIfNotLoggedIn="false" RequiredAccess="UserAccessLevel.Developer">
                    <TextEditor Identifier="@($"report-desc-{Id}")" Placeholder="New description..."
                                FieldLabel="Description" CurrentlySavedText="@Data.Description"
                                GetSaveRequest="@GetDescriptionSaveRequest"/>
                </AccessLimited>

                <h3>Callstack</h3>

                <pre>@Data.CondensedCallstack</pre>

                <h4>Full Stack Details</h4>
                <pre>@Data.PrimaryCallstack</pre>

                <AccessLimited AutoRedirectIfNotLoggedIn="false" RequiredAccess="UserAccessLevel.Developer">
                    <AuthorizedContent>
                        <h3>Logs</h3>

                        @if (fetchingLogs)
                        {
                            <span class="spinner-border spinner-border" role="status" aria-hidden="true"></span>
                        }
                        else
                        {
                            <pre>@logs</pre>
                        }

                        <p>Note: logs and crash dump won't auto refresh on data change.</p>

                    </AuthorizedContent>
                    <AccessMissingContent>
                        <h3>Logs</h3>

                        <p>
                            Only Thrive developers can view logs.
                            <NavLink href="@navigationManager.GetLinkToLogin("Only developers can view logs")">
                                Login
                            </NavLink>
                        </p>

                    </AccessMissingContent>
                </AccessLimited>
            </div>

            <div class="col-12 col-xl overflow-auto">
                <AccessLimited AutoRedirectIfNotLoggedIn="false" RequiredAccess="UserAccessLevel.Developer">
                    <h3>Crash dump</h3>
                        @if (fetchingCrashDump)
                        {
                            <span class="spinner-border spinner-border" role="status" aria-hidden="true"></span>
                        }
                        else
                        {
                            <pre>@crashDump</pre>
                        }

                        <StatusMessageShower Type="@bottomStatusType" Message="@bottomStatus" />

                        @if (Data.CanReProcess)
                        {
                            <Button ButtonStyle="secondary" Spinner="@reprocessingFile"
                                    Enabled="@(!reprocessingFile)" OnPressed="@RequestReProcessing">
                                Reprocess Dump File
                            </Button>
                        }
                        else
                        {
                            <p>Crash dump for this report has been deleted.</p>
                        }
                </AccessLimited>
            </div>
        </div>

        @* TODO: implement commenting at some point
        <h3>Comments</h3>
        *@

        @* TODO: implement notification registering
        <h3>Notifications</h3>
        *@
    }
</SingleResourceDisplayer>

@code {

    private const int SmallDuplicateAmount = 5;

    private SiteNoticeType topStatusType = SiteNoticeType.Info;
    private string topStatus;

    private SiteNoticeType bottomStatusType = SiteNoticeType.Info;
    private string bottomStatus;

    private bool reprocessingFile;

    private bool fetchingDuplicates;
    private List<long> duplicates;
    private bool showAllDuplicates;

    private bool fetchingLogs;
    private string logs;

    private bool fetchingCrashDump;
    private string crashDump;


    [Parameter]
    public string FileBrowserPath { get; set; }

    protected override Task<CrashReportDTO> StartQuery()
    {
        return http.GetFromJsonAsync<CrashReportDTO>($"api/v1/CrashReport/{Id}");
    }

    public override void GetWantedListenedGroups(UserAccessLevel currentAccessLevel, ISet<string> groups)
    {
        groups.Add(NotificationGroups.CrashReportUpdatedPrefix + Id);
    }

    public async ValueTask DisposeAsync()
    {
        await notificationHandler.Unregister(this);
    }

    protected override async Task OnFirstDataReceived()
    {
        await notificationHandler.Register(this);

        var tasks = new List<Task> { FetchDuplicates() };

        if (currentUserInfo.IsDeveloper)
        {
            tasks.Add(FetchLogs());
            tasks.Add(FetchCrashDump());
        }

        await Task.WhenAll(tasks);
    }

    private async Task FetchDuplicates()
    {
        duplicates = null;
        fetchingDuplicates = true;
        topStatus = null;
        await InvokeAsync(StateHasChanged);

        try
        {
            duplicates = await http.GetFromJsonAsync<List<long>>($"api/v1/CrashReport/{Id}/duplicates");
        }
        catch (Exception e)
        {
            topStatus = $"Fetching duplicates failed: {e.Message}";
            topStatusType = SiteNoticeType.Danger;
        }
        finally
        {
            fetchingDuplicates = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task FetchLogs()
    {
        logs = null;
        fetchingLogs = true;
        topStatus = null;
        await InvokeAsync(StateHasChanged);

        try
        {
            logs = await http.GetStringAsync($"api/v1/CrashReport/{Id}/logs");
        }
        catch (Exception e)
        {
            topStatus = $"Fetching logs failed: {e.Message}";
            topStatusType = SiteNoticeType.Danger;
        }
        finally
        {
            fetchingLogs = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task FetchCrashDump()
    {
        crashDump = null;
        fetchingCrashDump = true;
        topStatus = null;
        await InvokeAsync(StateHasChanged);

        try
        {
            crashDump = await http.GetStringAsync($"api/v1/CrashReport/{Id}/decodedDump");
        }
        catch (Exception e)
        {
            topStatus = $"Fetching crash dump failed: {e.Message}";
            topStatusType = SiteNoticeType.Danger;
        }
        finally
        {
            fetchingCrashDump = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task RequestReProcessing()
    {
        reprocessingFile = true;
        bottomStatus = null;
        bottomStatusType = SiteNoticeType.Danger;
        await InvokeAsync(StateHasChanged);

        HttpResponseMessage result;

        try
        {
            result = await http.PostAsync($"api/v1/CrashReport/{Id}/reprocess", new StringContent(string.Empty));
        }
        catch (HttpRequestException e)
        {
            bottomStatus = $"Network request failed: {e.Message}";
            reprocessingFile = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        reprocessingFile = false;

        if (!result.IsSuccessStatusCode)
        {
            var content = await result.Content.ReadAsStringAsync();

            bottomStatus = $"Error, server responded with: {content}, {result.StatusCode}";
        }
        else
        {
            bottomStatus = "Report reprocessing queued";
            bottomStatusType = SiteNoticeType.Primary;
        }

        await InvokeAsync(StateHasChanged);
    }

    private Task SetDuplicatesFullShowing(bool showAll)
    {
        showAllDuplicates = showAll;
        return InvokeAsync(StateHasChanged);
    }

    private Tuple<string, object> GetDescriptionSaveRequest(string newDescription)
    {
        var result = (CrashReportDTO)Data.Clone();
        result.Description = newDescription;

        return new Tuple<string, object>($"api/v1/CrashReport/{Id}", result);
    }
}
